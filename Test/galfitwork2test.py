from astropy.io import fits
import numpy as np
import math
import matplotlib.pyplot as plt
from astropy import constants as const

class GalfitComponent(object):
    
    def __init__(self,galfitheader,component_number):
        #"""
        #takes in the fits header from HDU 3 (the galfit model) from a galfit output file
        #and the component number to extract
        #"""
        #checks
        assert component_number > 0
        assert "COMP_" + str(component_number) in galfitheader

        self.component_type = galfitheader["COMP_" + str(component_number)]
        self.component_number = component_number
        headerkeys = [i for i in galfitheader.keys()]
        comp_params = []
        for i in headerkeys:
            if str(component_number) + '_' in i:
                comp_params.append(i)
        for param in comp_params:
            val = galfitheader[param]
            #we know that val is a string formatted as 'result +/- uncertainty'
            #if val is fixed in GalFit, it is formatted as '[result]'
            paramsplit = param.split('_')
            
            # If there's some numerical error, should output a warning (*)
            
            if '[' in val:     #fixed parameter
            #    val = val.translate('[]*')
                val = val.replace('[','').replace(']','')
                setattr(self,paramsplit[1].lower(),float(val))
                setattr(self,paramsplit[1].lower() + '_err',None)
            else:              #normal variable parameter
                val = val.split()
                setattr(self,paramsplit[1].lower(),float(val[0]))
                setattr(self,paramsplit[1].lower() + '_err',float(val[2]))
            
class GalfitResults(object):
  #  """
  #  This class stores galfit results information
  #  INPUT:
  #      galfit_fits_file: the block fits file generated by GalFit
  #  """
    def __init__(self, galfit_fits_file):
    #    """
    #    init method for GalfitResults. Take in a string that is the name
    #    of the galfit output fits file
    #    """
        hdulist = fits.open(galfit_fits_file)
        #now some checks to make sure the file is what we are expecting
        assert len(hdulist) == 4
        galfitmodel = hdulist[2]
        galfitheader = galfitmodel.header
        galfit_in_comments = False
        for i in galfitheader['COMMENT']:
            galfit_in_comments = galfit_in_comments or "GALFIT" in i
        assert True == galfit_in_comments
        assert "COMP_1" in galfitheader
        #now we've convinced ourselves that this is probably a galfit file
        
        self.galfit_fits_file = galfit_fits_file
        #read in the input parameters
        self.input_initfile = galfitheader['INITFILE']
        self.input_datain = galfitheader["DATAIN"]
        self.input_sigma = galfitheader["SIGMA"]
        self.input_psf = galfitheader["PSF"]
        self.input_constrnt = galfitheader["CONSTRNT"]
        self.input_mask = galfitheader["MASK"]
        self.input_fitsect = galfitheader["FITSECT"]
        self.input_convbox = galfitheader["CONVBOX"]
        self.input_magzpt = galfitheader["MAGZPT"]
        
        #read in the chi-square value
        self.chisq = galfitheader["CHISQ"]
        self.ndof = galfitheader["NDOF"]
        self.nfree = galfitheader["NFREE"]
        self.reduced_chisq = galfitheader["CHI2NU"]
        
        #find the number of components
        num_components = 1 #already verified above
        while True:
            if "COMP_" + str(num_components + 1) in galfitheader:
                num_components = num_components + 1
            else:
                break
        self.num_components = num_components

        for i in range(1, self.num_components + 1):
            setattr(self,"component_" + str(i),GalfitComponent(galfitheader,i))
        #print(galfitmodel)
        hdulist.close()
#print(galfitmodel)
#print('ending here')
myresults=GalfitResults('galfitoutputFINAL.fits')
for key in myresults.__dict__:
    print(f'{key} ')
print('COMP1')
print(myresults.component_1.__dict__)
#print(myresults.input_magzpt)
#print(myresults.component_1.sky)
print('COMP2')
print(myresults.component_2.__dict__)
print('COMP3')
print(myresults.component_3.__dict__)
print(myresults.component_2.mag)
print(myresults.component_3.mag)

print(' ')
print('Start Converting Mag to Flux')
#fzero aus https://irsa.ipac.caltech.edu/data/SPITZER/docs/irac/iracinstrumenthandbook/17/ 
fzero = 280.9
#flux berechnen
#formel aus https://irsa.ipac.caltech.edu/data/SPITZER/docs/irac/iracinstrumenthandbook/24/
#fluxE = 10**(((-1)*myresults.component_2.mag/2.5)+np.log10(fzero))

#print(fluxE)
#fluxS = 10**(((-1)*myresults.component_3.mag/2.5)+np.log10(fzero))
#print(fluxS)

fluxE = 10**((myresults.component_2.mag-2.5*np.log10(fzero))/-2.5)
print(fluxE)
#fluxS = 10**(((-1)*myresults.component_3.mag/2.5)+np.log10(fzero))
fluxS = 10**((myresults.component_3.mag-2.5*np.log10(fzero))/-2.5)
print(fluxS)
#converting flux density from Jy (Watt/m²/Hz) to Watt/m^2/hz -
WattmE = fluxE * 10**-26
WattmS = fluxS * 10**-26
print(WattmE)
print(WattmS)
#convert flux density to flux for 3.6micron, that means frequenz*Fluxdensity
#so we need for frequenz= c/lambda mit lambda=3.6micron=3.6*10^-6
frequenz = const.c / (3.6*10**-6)
print ('frequenz ist')
print(frequenz)
WattE = WattmE * frequenz
WattS = WattmS * frequenz
print('watt values')
print(WattE)
print(WattS)
#Converting Flux to Lum with L=4pi*r*r
#Distance from Object to us in Meter converted from parsec to meter, merke: distanz ist 29,4Mpc
DistanzMeter = 29400000*3.086*(10**16)
LumE = WattE*4*math.pi*DistanzMeter*DistanzMeter
LumS = WattS*4*math.pi*DistanzMeter*DistanzMeter
#bc of using bolometric mag, /Hz disappears
print('---------------')
print('LumE')
print(LumE)
print('LumS')
print(LumS)
#trying to convert into solar Luminosity Solar-Lum bei 3.828x10e26W, hier mit SolarLum in 3.6micron ersetzen, converting with L=Solarlum*10^0.4Mag hier mit vegamag=3.26
SolarE = LumE /  (3.828*(10**26))# * 10**(-0.4*3.24) )
SolarS = LumS /  (3.828*(10**26))# * 10**(-0.4*3.24) )
print('----------')
print('LumE in SolarLum')
print(SolarE)
print('LumS in SolarLum')
print(SolarS)

#Die ermittelten Werte nun in eine Textfile schreiben
with open ('UmgewandelteWerteMagZuFlux.txt','w+') as f:
    f.write('FluxExpDisk')
    f.write ('  \n')
    f.write('%s' % fluxE)
    f.write ('  \n')
    f.write ('  \n')
    f.write('FluxSersic')
    f.write ('  \n')
    f.write('%s' % fluxS)
f.close()
print('Ending Converting Mag to Flux')
print(' ')
print('Start Converting Pixel to Arcsecond to Parsec ')
#Konvertiere rs (Expdisk) und re (Sersic) in Arcsecond
print('Pixelvalues:') 
print(myresults.component_2.rs)
print(myresults.component_3.re)
print('Converting Pixel to Arcseconds')
Earc=0.75*myresults.component_2.rs
Sarc=0.75*myresults.component_3.re
print('Arcsecondvalues:')
print(Earc)
print(Sarc)
print('Converting Arcseconds to Radians')
Erad=Earc*4.8481e-6
Srad=Sarc*4.8481e-6
print(Erad)
print(Srad)
print('Converting Radians to Parsec')
#in kpc aus NED, die 29400 ist die distanz zwischen beobachter und objekt 
Ekpars=2*(29400*np.tan(Erad/2)) 
Skpars=2*(29400*np.tan(Srad/2)) 
Epars = Ekpars * 1000
Spars = Skpars * 1000
print('Parsecvalues:')
print(Epars)
print(Spars)
print ('kpc values')
print(Ekpars)
print(Skpars)
#hier noch einfügen, dass man das noch in eine Textdatei schreiben lassen soll
print('Ending Converting Pixel to Arcsecond to Parsec')
print(' ')
print('Start Plot Mag Radius')
#Zunächst mal Ezero finden, also das Summenzeichen im GALFIT readme mit der null im index
#Dazu braucht man Ftot, also Flux und q, die Axis Ratio und rs die Scale Lengh wie oben
print(fluxE)
print(fluxS)
#scale lengh and eff radius
print('Scale Lengh and Effective Radius in Pixel')
print(myresults.component_2.rs)
print(myresults.component_3.re)
print ('Scale Lengh and Effective Radius in Parsec')
print(Epars)
print(Spars)
#axis ratios
print(myresults.component_2.ar)
print(myresults.component_3.ar)
print(Epars)
print(Spars)
Ezero=SolarE/(2*math.pi*Epars*Epars*myresults.component_2.ar)
print('Ezero is')
print(Ezero)
#kappa definieren mit kappa=2n-1/3 aus wikipedia für sersic profile, alle kpc values in pc umwandeln
print(myresults.component_3.n)
kappa=2*myresults.component_3.n-(1/3)
print(kappa)
ESeff=SolarS/(2*math.pi*Spars*Spars*np.exp(kappa)*myresults.component_3.n*(kappa**(-2*myresults.component_3.n))*myresults.component_3.ar*math.gamma(2*myresults.component_3.n))
print('ESeff is')
print(ESeff)
#versuche umrechnungsfaktor zu erstellen, y axis mit kpc versehen! 
#Added: 0.45Msun/Lsun for 3.6micron

def main():
    x = np.linspace(0, 6, 100)
    y = Ezero*np.exp(-x/Ekpars) * 0.45
   # plt.yscale('log')
    fig = plt.figure()
    plt.yscale('log')
   # y = np.arange(1,100)
   # bottom, top = ylim()
   # ylim(bottom=1)
   # axes= fig.add_axes(0.1,0.1,0.8,0.8)
   # axes.set_ylim([1,100])
    plt.plot(x, y)
    plt.axis([0,6,1,300])
    plt.xlabel('Radius (kpc)')
    plt.ylabel('Mass (M$_{\odot}$)/pc²')
    plt.tight_layout()
    plt.savefig('NEUexpdiskplotTest.png', bbox_inches='tight')
    plt.show()
   # plt.savefig('Testplot.png')
    
    sx = np.linspace(0, 6, 100)
    sy = ESeff*np.exp((-1)*kappa*((sx/Skpars)**(1/myresults.component_3.n)-1)) * 0.45
    plt.figure()
    plt.yscale('log')
    plt.plot(sx, sy)
    #sy = np.arange(1,100)
    plt.axis([0,6,1,300])
    plt.xlabel('Radius (kpc)')
    plt.ylabel('Mass (M$_{\odot}$)/pc²')
    plt.savefig('NEUsersicplotTest.png')
    plt.show()
    
    plt.yscale('log')
    plt.plot(x, y)
    plt.plot(sx, sy)
    plt.plot(x,(y+sy))
    plt.xlabel('Radius (kpc)')
    plt.ylabel('Mass (M$_{\odot}$)/pc²')
    plt.axis([0,6,1,300])
    plt.savefig('NEUsersicexpdiskplotTest.png', bbox_inches='tight')
    plt.show()

 #   plt.yscale('log')
   # ux = np.linspace(0, 1, 200)
  #  seins= y+sy
  #  uy = 10**((seins-3.26-21.572)/(-1)*2.5)   
  #  plt.plot(x, uy)
  #  plt.savefig('SolarLumpcAS.png', bbox_inches='tight')
  #  plt.show()
    
#hier muss noch der plot für sersic rein, done

if __name__ == '__main__':
    main()



with open ('NEUErrechneteWerteTabelleTEST.txt','w+') as f:
    f.write('FluxExpDisk')
    f.write ('  \n')
    f.write('%s' % fluxE)
    f.write ('  \n')
    f.write ('  \n')
    f.write('FluxSersic')
    f.write ('  \n')
    f.write('%s' % fluxS)
    f.write ('  \n')
    f.write ('  \n')
    f.write('Scalelengh Expdisk in Arcsec')
    f.write ('  \n')
    f.write('%s' % Earc)
    f.write ('  \n')
    f.write ('  \n')
    f.write('Effective Radius Sersic in Arcsec')
    f.write ('  \n')
    f.write('%s' % Sarc)
    f.write ('  \n')
    f.write ('  \n')
    f.write('Scalelengh Expdisk in Radian')
    f.write ('  \n')
    f.write('%s' % Erad)
    f.write ('  \n')
    f.write ('  \n')
    f.write('Effective Radius Sersic in Radian')
    f.write ('  \n')
    f.write('%s' % Srad)
    f.write ('  \n')
    f.write ('  \n')
    f.write('Scalelengh Expdisk in pc')
    f.write ('  \n')
    f.write('%s' % Epars)
    f.write ('  \n')
    f.write ('  \n')
    f.write('Effective Radius Sersic in pc')
    f.write ('  \n')
    f.write('%s' % Spars)
    f.write ('  \n')
    f.write ('  \n')
    f.write('Ezero')
    f.write ('  \n')
    f.write('%s' % Ezero)
    f.write ('  \n')
    f.write ('  \n')
    f.write('ESeff')
    f.write ('  \n')
    f.write('%s' % ESeff)
    f.write ('  \n')
    f.write ('  \n')
    f.write('Luminosity and SolarLum Expdisk')
    f.write ('  \n')
    f.write('%s' % LumE)
    f.write ('  \n')
    f.write('%s' % SolarE)
    f.write ('  \n')
    f.write ('  \n')
    f.write('Luminosity and SolarLum Sersic')
    f.write ('  \n')
    f.write('%s' % LumS)
    f.write ('  \n')
    f.write('%s' % SolarS)
f.close()

print(myresults.component_1.__dict__)
print(myresults.component_2.__dict__)
print(myresults.component_3.__dict__)


#hier für rotationskurve in gipsy mal die werte für 12 bis 144 arcsec in 12er schritten jeweils zu expdisk und sersic in die plot formeln einfügen
print ('NEW TASK FOR GIPSY')
gip= np.array([3.4,6.8,10.2,13.6,17,20.4,23.8,27.2,30.6])
print('Parsec Values of Ring Radii')
print(gip)
gip1outbulge= ESeff*np.exp((-1)*kappa*((gip/Skpars)**(1/myresults.component_3.n)-1)) * 0.45
print(gip1outbulge)
print('NOW TO EXPDISK')
gip1outexpdiskfinal = Ezero*np.exp((-1)*gip/Ekpars) * 0.45
print(gip1outexpdiskfinal)


